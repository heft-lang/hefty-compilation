\documentclass[sigplan,anonymous,review]{acmart}

%include polycode.fmt

% \bibliographystyle{plainurl}% the mandatory bibstyle

\title{Modular Compilation using Effects}

\author{Jaro S. Reinders} % {Delft University of Technology, Netherlands}{j.s.reinders@tudelft.nl}{https://orcid.org/0000-0002-6837-3757}{} % (Optional) author-specific funding acknowledgements}

\begin{document}

\begin{abstract}

\end{abstract}

\maketitle

\section{Introduction (1 page)} \label{sec:intro}

Modern compilers for mature programming languages commonly consist of hundreds of thousands to tens of millions lines of code.
At the same time, programming languages are still very actively developed.
In the last 12 years many new programming languages have appeared, such as Kotlin, Rust, and Swift.
Rewriting all those lines of code for each new language is very costly.
It is not a coincidence that all three languages are built on top of mature compiler platforms such as the JVM and LLVM.

However, the interface of these platforms, the intermediate representations (IR), are all monolithic and therefore limited to a single level of abstraction.
That means that languages often still need to use a separate IR at a different level of abstraction for their own language specific transformations and optimizations.

How can we design a compiler platform which allows for maximum reuse across a large variety of programming languages?

The most important aspect of a compiler framework is the intermediate representation(s).
An intermediate representation is the data structure that is used by the compiler to represent programs.

The approach we present is based on ideas that have a long history in the literature, namely denotational semantics, monads, and algebraic effects.
It is no coincidence that the theory of programming language semantics plays a role in our compiler framework, because compilation is essentially a way of giving a semantics to a programming language.
Monads and algebraic effects are related concepts that make it possible to define denotational semantics in a modular way.



% Moggi later introduced monads and monad morphisms to enable the modular definition of denotational semantics.
% Plotkin and Power presented a more ergonomic alternative to monad morphisms which just considered abstract algebraic effect interfaces.
% Plotkin and Pretnar made it possible to define practical programs in this paradigm of algebraic effects by introducing handlers which give semantics to the abstract operations of algebraic effects.
% Wu, Schrijvers, and Hinze observed that some language constructs such as exception catching did not fit into the algebraic effect framework and proposed a framework for more general scoped effects that does support exceptions.
% Van den Berg, Schrijvers, Bach Poulsen, and Wu observe yet more language constructs which do not fit into the algebraic effect framework and not even in the scoped effect framework.
% They introduce latent effects which are more general still.
% 
% Denotational semantics is about defining the meaning of programs by mapping the programs onto mathematical objects.
% Strachey's original school of thought exclusively used the lambda calculus the mathematical object to map programs onto, even before Scott proved that the lambda calculus is really a mathematical object. 
% Moggi's monads allow one to abstract over common patterns in these mappings which makes it easier to define the mapping.
% Monad morphisms allow for combining different monads in the same mapping, making the mapping modular. 

Directions (roughly in order of difficulty):
\begin{enumerate}
  \item Ergonomic IR for education. Requires contrasting with nanopass and Siek's book. Prior work: Nanopass compilation for education.
  \item Modular IR for reusability. Requires nontrivial compilers for multiple languages sharing many components. Prior work: Bridging the Gulf
  \item Efficient IR for optimizations. Requires efficient implementations of optimizations. Prior work: Compiling with Continuations, or without. Whatever!
  \item Formal Verification. Requires proofs of correctness of compilation. Prior work: Interaction Trees.
\end{enumerate}

\begin{itemize}
  \item What are the main ideas behind this paper?
  \item Why is it different from previous work?
\end{itemize}

Concretely, our contributions are:
\begin{itemize}
  \item We show how to build a modular compiler from a small language to a subset of X86 in Section~\ref{sec:simple-lang}.
  \item We demonstrate analyses and transformation over our modular IR in Section~\ref{sec:analysis}.
  \item We demonstrate the modularity of our approach by extending our compiler with conditionals and loops in Section~\ref{sec:cond-loops}.
  \item We evaluate our approach by compiling a suite of example programs and observing the behavior of the resulting binaries in Section~\ref{sec:evaluation}
\end{itemize}

\section{Effects and Handlers (3 page)} \label{sec:effects-handlers}

In this section we explain what effects and handlers are and show how they can be used in the context of compilers.

\begin{itemize}
  \item Keep high level
  \item Explain what the signatures are
  \item Show example program with high level effect like Arith and I/O and an equivalent program in X86 with variables (show types)
  \item High level overview of the whole approach
  \item Show effectful definitional interpreters
  \item Foreshadow reuse and other nice properties by using interpreters over multiple passes (maybe even full pipeline)
  \item (higher order functions would be nice)
\end{itemize}

\section{Syntactic Representation of Free Monads (1 page)}
  
\begin{itemize}
\item Show Free Monad refer to DTC
\item Show why the higher order representation is problematic
\end{itemize}

\section{Compiling a Simple Language to X86 (1 pages)} \label{sec:simple-lang}

In this section we introduce a simple language and show how it can be compiled to X86 with variables.

\section{Register Allocation (2 pages)} \label{sec:analysis}

In this section we show how we can remove the variables from our X86 representation.
This also serves as a demonstration of running an analysis over our modular IR.

\section{Adding Conditionals and Loops (2 pages)} \label{sec:cond-loops}

In this section we show that we can extend our language with new concepts without modifying code we have already written.

\section{Evaluation (1 pages)} \label{sec:evaluation}

In this section we evaluate the correctness of our compilers.

\begin{itemize}
  \item Use Siek's examples
\end{itemize}

\section{Related Work (1/2 page)} \label{sec:related}

\begin{itemize}
  \item MLIR
  \item nanopass compilation
  \item Hefty Algebras
  \item Using a monadic intermediate representation has been a successful research direction (Benton's, Hughes', and Moggi's "Monads and Effects" has many references, and https://www.habit-lang.org/ uses a monadic intermediate language MIL)
\end{itemize}

\section{Conclusion and Future Work(1/2 page)} \label{sec:conclusion}



Future work:
\begin{itemize}
  \item Formal verification
\end{itemize}

\end{document}