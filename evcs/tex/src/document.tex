
\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate, anonymous]{oasics-v2021}
%This is a template for producing OASIcs articles. 
%See oasics-v2021-authors-guidelines.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling autoref support, use "autoref"
%for anonymousing the authors (e.g. for double-blind review), add "anonymous"
%for enabling thm-restate support, use "thm-restate"
%for enabling a two-column layout for the author/affilation part (only applicable for > 6 authors), use "authorcolumns"
%for producing a PDF according the PDF/A standard, add "pdfa"

%\pdfoutput=1 %uncomment to ensure pdflatex processing (mandatatory e.g. to submit to arXiv)
%\hideOASIcs %uncomment to remove references to OASIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{Towards Modular Compilation using Higher-order Effects}

\author{Jaro S. Reinders}{Delft University of Technology, Netherlands}{j.s.reinders@tudelft.nl}{https://orcid.org/0000-0002-6837-3757}{} % (Optional) author-specific funding acknowledgements}

\authorrunning{J.S. Reinders}

\Copyright{Jaro S. Reinders}

\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10003752.10010124.10010131</concept_id>
<concept_desc>Theory of computation~Program semantics</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10011007.10011006.10011041</concept_id>
<concept_desc>Software and its engineering~Compilers</concept_desc>
<concept_significance>500</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Program semantics}
\ccsdesc[500]{Software and its engineering~Compilers}

\keywords{algebraic effects and handlers, higher-order effects, monadic semantics, modularity, compilation, nanopass}

% \category{} %optional, e.g. invited paper

% \relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversiondetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93]{Classification (e.g. Full Version, Extended Version, Previous Version}{URL to related version} %linktext and cite are optional

%\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...
%\supplementdetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93, subcategory={Description, Subcategory}, swhid={Software Heritage Identifier}]{General Classification (e.g. Software, Dataset, Model, ...)}{URL to related version} %linktext, cite, and subcategory are optional

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

% \acknowledgements{I want to thank \dots}%optional

%\nolinenumbers %uncomment to disable line numbering

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand\bind[1]{>\!\!>\!\!= \lambda #1.\,}
\newcommand\then{>\!\!>}
\newcommand\append{+\!\!\!\!+~}


\begin{document}

\maketitle

\begin{abstract}
  Compilers transform a human readable source language into machine readable target language.
  Nanopass compilers simplify this approach by breaking up this transformation into small steps that are more understandable, maintainable, and extensible.
  We propose a semantics-driven variant of the nanopass compiler architecture exploring the use a effects and handlers to model the intermediate languages and the transformation passes, respectively.
  Our approach is fully typed and ensures that all cases in the compiler are covered.
  Additionally, by using an effect system we abstract over the control flow of the intermediate language making the compiler even more flexible.
  We apply this approach to a minimal compiler from a language with arithmetic and let-bound variables to a string of pretty printed X86 instructions.
  In the future, we hope to extend this work to compile a larger and more complicated language and we envision a formal verification framework from compilers written in this style.
\end{abstract}

\section{Introduction}

The essence of a compiler is a function from a source language, suitable for humans, to a machine language, suitable for computers.
As our computers have become more powerful we have seen increasingly complex compilers providing extensive safety guarantees and powerful optimizations.
To manage this complexity, modern compilers are designed as a composition of multiple passes.
However, the total number of passes has traditionally been kept low for the sake of performance, because each pass adds extra overhead.
Thus, compiler passes are more complicated than necessary and therefore harder to \emph{understand}, \emph{maintain}, and \emph{extend}.

To address this problem, Sarkar et al. introduce the nanopass compiler architecture~\cite{10.1145/1016850.1016878}.
In the nanopass architecture, each pass is designed to be as small as possible and has only a single purpose.
To make development of nanopass compilers easier Sarkar et al. proposed a methodology where each pass only has to specify transformation rules for those language elements which they actually modify.
Additionally, intermediate representations of nanopass compilers can be specified by listing language elements which are removed or added to an existing intermediate representation.
To address concerns about the performance of this architecture, Keep and Dybvig have developed a competitive commercial compiler using this architecture~\cite{10.1145/2544174.2500618}.

In this paper, we present our ongoing work on developing an improved nanopass architecture.
As our foundation we use a higher-order effect system~\cite{10.1145/3571255} which is a state of the art technique for modeling the semantics of programming languages with side effects.
Our approach has the practical advantage of preventing type errors in the compiler and ensuring all cases are covered, which means that the passes defined using our architecture are guaranteed to be syntactically correct by construction.
Additionally, our approach abstracts over the control flow giving many of the benefits of continuation-passing-style while retaining a simple monadic interface.
% TODO: decide what to do with this. Probably just remove.
% While developing our approach, we are anticipating the possibility of verifying the correctness of compilers written in this style.
% We discuss that possibility briefly in our future work (Section~\ref{sec:conclusion}).

\noindent
Concretely, we make the following contributions:
\begin{itemize}
  \item We introduce a novel approach to designing and implementing practical compilers while staying close to formal denotational semantics specifications (Section~\ref{sec:compiling}). 
  \item We demonstrate our approach on a simple language with arithmetic and let-bound variables by compiling it to a subset of X86 (Section~\ref{sec:compiling}).
\end{itemize}

\section{Monads and Effects}

The compiler architecture we propose is based on the concept of monads, algebraic effects and handlers, and higher-order effect trees and their algebras.
In this section, we briefly introduce this required background.
This section contains no novel work except for the explanations themselves.

\subsection{Monads}

Monads are a concept from category theory that have been applied to the study of programming language semantics by Moggi~\cite{39155} and introduced to functional programming by Wadler~\cite{10.1145/91556.91592}.
A monad as used in this paper consists of four parts: 
\begin{itemize}
  \item a type $m$
  \item a binary operator $>\!\!>\!\!=~: m~a \to (a \to m~b) \to m~b$ (known as ``bind'')
  \item a binary operator $\then~: m~a \to m~b \to m~b$
  \item a function $\mathit{return} : a \to m~a$
\end{itemize}
The operator $x \then y$ is always defined to be equal to $x \bind{z} y$ where $z$ is free in $y$.
Furthermore, monads must satisfy three laws:
\begin{itemize}
  \item left identity: $return~x \bind{y} k~y = k~x$
  \item right identity: $x \bind{y} return~y = x$
  \item associativity: $x \bind{y} (k~y \bind{z} h~z) = (x \bind{y} k~y) \bind{z} h~z$
\end{itemize}

We can use monads is to define computations with side effects.
An example is the \textit{Maybe} monad which defines partial computations.
The type consists of two constructors: $\mathit{Just}: a \to \mathit{Maybe}~a$ and $\mathit{Nothing} : \mathit{Maybe}~a$.
The bind operator sequences partial computations such that if one subcomputation fails then the whole computation fails.
That behavior can be defined using the following two equations: $\mathit{Nothing} \bind{x} k~x = \mathit{Nothing}$ and $\mathit{Just}~x \bind{y} k~y = k~x$.
The return function is the $\mathit{Just}$ constructor.
From these definitions it is straightforward to prove that the laws hold, so we will not show the proofs in this paper.

Using the maybe monad we can define a checked division function assuming we have access to an unchecked division function: 
\[
  \mathit{checkedDiv}~x~y = \begin{cases} 
    \mathit{Just}~(\mathit{div}~x~y) & \text{if}~y \neq 0 \\
    \mathit{Nothing} & \text{if}~y = 0
  \end{cases}
\]

Using this checked division function we can define another function that divides a number $c$ by all the numbers contained in a list and return the result in a list:
\begin{alignat*}{2}
  & \mathit{divAll}~c~\mathit{Nil} && = \mathit{return}~\mathit{Nil} \\
  & \mathit{divAll}~c~(x :: xs) && = 
    \mathit{checkedDiv}~c~x \bind{x'}
    \mathit{divAll}~c~xs \bind{xs'}
    \mathit{return}~(x' :: xs')
\end{alignat*}

In this case, the monad has allowed us to implicitly get the control flow behavior that the whole computation will abort if there is at least one zero in the list.

\subsection{Effects}

One problem with using monads for specifying the semantics of side effects of programming languages is that you need to define a whole new monad for every programming language, even if many programming languages have side effects in common.

Plotkin and Power addressed this problem by introducing algebraic effects~\cite{10.1007/3-540-45315-6_1}, focusing on the effectful operations themselves rather than the concrete monad type.
Any set of effectful operations gives rise to a monad for free.
In this way, the same operations can be reused in two different modular monads.

In this paper we group effectful operations into units which we call 'effects'. For example we can define the interface of an effect called 'Abort' as follows:

\vspace{1em}
\textbf{effect} Abort \textbf{where}
\vspace{-1em}
\begin{alignat*}{1}
  \quad\mathit{abort} & :  m~a
\end{alignat*}

This definition shows that the Abort effect has one operation called 'abort' which takes no arguments.
The type of abort is polymorphic in both the effectful context $m$ and the return type $a$.
In this paper, we assume the obvious implicit constraint that the defining effect, in this case Abort, must be part of the effectful context $m$.

Any combination of effects gives rise to a monad.
So, we can start using the Abort effect to define the \textit{checkedDiv} function instead of using the concrete \textit{Maybe} monad as follows:
\[
  \mathit{checkedDiv}~x~y = \begin{cases} 
    \mathit{return}~(\mathit{div}~x~y) & \text{if}~y \neq 0 \\
    \mathit{abort} & \text{if}~y = 0
  \end{cases}
\]
The implementation of the \textit{divAll} function does not need to be changed.

Now, let us consider the meaning of the Abort effect.
The fact that the \textit{abort} operation claims to produce any polymorphic $a$ as result might seem strange.
A normal interface or type class in most programming languages would not be able to implement such a function, because it is impossible to produce a value if the type of that value is not fixed.
The reason that we are able to define our effectful operation like this is because one possible side effect is to stop the rest of the computation.
That way we do not actually have to produce such a value at all.

In general, to define the meaning of effects we use handlers as introduced by Plotkin and Pretnar~\cite{10.1007/978-3-642-00590-9_7}.
Effect handlers can be thought of as exception handlers with the ability to resume the computation at the location where an effect operation which is handled was used.
For the Abort effect, the usual implementation is defined by the following handler:
\begin{alignat*}{2}
  & \mathbf{handle} && \\
  & \quad\mathit{abort}~k && \to \mathit{Nothing} \\
  & \quad\mathit{return}~x && \to \mathit{Just}~x
\end{alignat*}
This example shows that the handler of an effect lists each operation and how it should be handled.
In addition to the operations themselves, the handler has access to the continuation $k$ from the point where the operation was used.
Furthermore, the Abort handler has a \textit{return} case for when the computation contains no usage of the \textit{abort} operation.
For most handlers in this paper, the \textit{return} case is just $\textit{return}~x \to \textit{return}~x$ in which case we simply leave it out.

Finally, in this paper we use a higher-order effect system introduced by Bach Poulsen and Van der Rest~\cite{10.1145/3571255}.
Higher-order effect operations are those operations that take effectful computations as arguments.
That can be useful for scoping operations, such as exception catching, but also thunks in lazy programming languages.
Bach Poulsen and Van der Rest show that it is possible to use their effect system to define interpreters for such higher-order effects.
So, it is more than expressive enough for the minimal compiler we present in this paper and even we expect it gives us room to expand our compiler in the future.

\section{Compiling with Higher-order Effects}\label{sec:compiling}

In this section, we present our approach by applying it to a very simple language with arithmetic and let-bound variables.
The target language of our compiler is X86 machine code.
We explain the required concepts as we develop our compiler for this language.
The specifications and compiler passes are presented in a simplified notation, but we have implemented all the work we present here in the Agda programming language~\cite{10.1007/978-3-642-03359-9_6}.
Our code can be found on GitHub\footnote{\url{https://github.com/heft-lang/hefty-compilation}}.

We start off by assuming our parser and possibly type checker has finished and produced an abstract syntax tree which follows the grammar described in Figure~\ref{fig:source-absyn}.
Our language has integers, addition, subtraction, negation, a read operation to read an input integer, and a let to bind variables and a var to refer to bound variables.

The abstract syntax is unusual because we reuse the variable binding facilities from our host language in the form of the $\mathit{v} \to \mathit{expr}$ function in the let constructor.
This style of abstract syntax is called parametric higher-order abstract syntax (PHOAS) \cite{10.1145/1411203.1411226}.
It allows us to avoid the complexities of variable binding and thus simplify our presentation.
We believe other name binding approaches, such as De Bruijn indices~\cite{DEBRUIJN1972381}, could be used instead.
However, changing the name binding mechanism would also require changing our representation of effectful computations.

\begin{figure}[ht]
  \begin{align*}
    \mathit{expr} ::= &\ \mathrm{int}(n) \\
           | &\ \mathrm{add}(\mathit{expr},\mathit{expr}) \\
           | &\ \mathrm{sub}(\mathit{expr},\mathit{expr}) \\
           | &\ \mathrm{neg}(\mathit{expr}) \\
           | &\ \mathrm{read} \\
           | &\ \mathrm{let}(\mathit{expr}, \mathit{v} \to \mathit{expr}) \\
           | &\ \mathrm{var}(\mathit{v})
  \end{align*}
  \caption{Abstract syntax of our simple language with arithmetic and let-bound variables.}\label{fig:source-absyn}
\end{figure}

The first step of our compilation pipeline will be to denote these syntactic constructs onto an effectful computation.
We have chosen to divide our source language into four effects: Int, Arith, Read, and Let.

\begin{figure}[ht]
\begin{minipage}[t]{0.4\textwidth}
\textbf{effect} Int \textbf{where}
\vspace{-1em}
\begin{alignat*}{2}
  \mathit{int} & : \mathbb{Z} && \to m~\mathit{val}
\end{alignat*}

\textbf{effect} Arith \textbf{where}
\vspace{-1em}
\begin{alignat*}{2}
  \mathit{add} & : \mathit{val} \to \mathit{val} && \to m~\mathit{val} \\
  \mathit{sub} & : \mathit{val} \to \mathit{val} && \to m~\mathit{val} \\
  \mathit{neg} & : \mathit{val}                  && \to m~\mathit{val}
\end{alignat*}
\end{minipage}%
%
\begin{minipage}[t]{0.6\textwidth}
\textbf{effect} Read \textbf{where}
\vspace{-1em}
\begin{alignat*}{2}
  \mathit{read} & : m~\mathit{val}
\end{alignat*}

\textbf{effect} Let \textbf{where}
\vspace{-1em}
\begin{alignat*}{2}
  \mathit{let} & : m~\mathit{val} \to (\mathit{val} \to m~\mathit{val}) && \to m~\mathit{val}
\end{alignat*}
\end{minipage}
  \caption{The effects of our source language and their operations with type signatures.}\label{fig:source-ops}
\end{figure}

Figure~\ref{fig:source-ops} shows the operations that correspond directly to our source language.
% However, there are some particularities we address individually:
% \begin{itemize}
%   \item 
    To keep our example simple, we have chosen to use this single type for all values, but we keep the type abstract and simply call it `val'.
    Also note that we now need a special $\mathit{int}$ operation to inject integers into this abstract value type.

    The reason for keeping the value type abstract is twofold. 
    Firstly, this prevents us from accidentally attempting to use information from these run-time values at compile-time. 
    Secondly, at the end of the compilation, these values stand for register or memory locations.
    Keeping the values abstract gives us the freedom to choose the concrete representation later on in the compilation pipeline.
    We use this freedom in the last handler of this section where we convert the program to a string.
    There we choose the values to be strings.
%   \item 
%     We write the surrounding monadic context as $m$, which provides the standard $>\!\!>\!\!=$, $>\!\!>$, and $\mathit{return}$ operations.
%     The monadic context of each operation always includes at least the effect that the operation belongs to, but it can accommodate other effects too.
%     For example, the monadic context of $\mathit{int}~1 \bind{x} \mathit{add}~x~x$ contains at least the Int and Arith effects.
%   \item
%     Readers knowledgeable about effect systems might notice that the $\mathit{let}$ operation has arguments that are themselves monadic computations.
%     In standard algebraic effects and handlers this is not allowed, however our approach uses a novel higher-order effect formalism that does support such effectful subcomputations~\cite{10.1145/3571255}.
% \end{itemize}

The first pass of our compiler pipeline maps our abstract syntax from Figure~\ref{fig:source-absyn} onto the operations we have defined for our source language from Figure~\ref{fig:source-ops}.
This mapping, called a denotation and written using the $[\![ \cdot ]\!]$ notation, is a recursive traversal of the abstract syntax tree shown in Figure~\ref{fig:den}.
The result of this mapping is a monadic computation involving the Int, Arith, Read, and Let effects.

\begin{figure}[ht]
\begin{align*}
  [\![ \mathrm{int}(n) ]\!] & = \mathit{int}~n \\
  [\![ \mathrm{add}(e_1, e_2) ]\!] & = [\![ e_1 ]\!] \bind{x} [\![ e_2 ]\!] \bind{y} \mathit{add}~x~y \\
  [\![ \mathrm{sub}(e_1, e_2) ]\!] & = [\![ e_1 ]\!] \bind{x} [\![ e_2 ]\!] \bind{y} \mathit{sub}~x~y \\
  [\![ \mathrm{neg}(e) ]\!] & = [\![ e ]\!] \bind{x} \mathit{neg}~x \\
  [\![ \mathrm{read} ]\!] & = \mathit{read} \\
  [\![ \mathrm{let}(e,f) ]\!] & = \mathit{let}~[\![e]\!]~(\lambda x.\, [\![ f~x ]\!]) \\
  [\![ \mathrm{var}(x) ]\!] & = \mathit{return}~x
\end{align*}
  \caption{A denotational mapping from our abstract syntax onto our initial set of effectful operations.}\label{fig:den}
\end{figure}

Now that we have denoted our syntactic elements into our semantic domain as operations, we can start refining these operations to get closer to the desired target language which is X86 in our case.
% In the practice of algebraic effects, this refinement is facilitated by handlers as introduced by Plotkin and Pretnar~\cite{10.1007/978-3-642-00590-9_7}.
% These handlers give us access to the operations that occur in the program and the continuation of the program which we will simply call $k$.
% We only have to provide the rules that map the operation and continuation onto our semantic domain consisting of primitives, existing operations, or newly introduced operations.
The effect that we choose to handle first is the Let effect, which only has the $\mathit{let}$ operation.
We handle this operation by running the right hand side of the binding, passing the resulting value to the body, and finally passing the result of that to the continuation. In code that looks as follows:
\begin{align*}
  \mathbf{handle}~(\mathit{let}~e~f)~k & \to e \bind{x} f~x \bind{z} k~z
\end{align*}
Note that this defines a strict semantics for our let bindings.
By using a different handler we could give different semantics to our language.
This is an example of the flexibility of algebraic effects and handlers.

\begin{figure}[ht]
  \begin{minipage}[t]{0.4\textwidth}
  \textbf{effect} X86 \textbf{where}
  \vspace{-1em}
  \begin{alignat*}{3}
    & \mathit{addq}  && : \mathit{val} \to \mathit{val} && \to m~() \\
    & \mathit{subq}  && : \mathit{val} \to \mathit{val} && \to m~() \\
    & \mathit{negq}  && : \mathit{val}                  && \to m~() \\
    & \mathit{movq}  && : \mathit{val} \to \mathit{val} && \to m~() \\
    & \mathit{callq} && : \mathit{lab}                  && \to m~() \\
    & \mathit{reg}   && : \mathrm{Register}             && \to m~\mathit{val} \\
    & \mathit{deref} && : \mathrm{Register} \to \mathit{\mathbb{Z}} && \to m~\mathit{val}
  \end{alignat*}
  \end{minipage}
  \begin{minipage}[t]{0.4\textwidth}
  \textbf{effect} X86Var \textbf{where}
  \vspace{-1em}
  \begin{align*}
    \mathit{x86var} : m~\mathit{val}
  \end{align*}
  \end{minipage}
  \caption{The effects related to X86 and their operations with type signatures.}\label{fig:x86-ops}
\end{figure}

At this point, since our language is so simple we can already begin translating into our target language.
In Figure~\ref{fig:x86-ops} we show a minimal subset of X86 that we need to compile our Arith and Read effects.
This subset contains in-place arithmetic instructions, the ubiquitous move instruction, the call instruction, and an operation to inject concrete registers into our abstract value type.
Additionally, we add an operation to generate fresh variables and inject them into our abstract value type.

We can translate our Arith effect operations into X86 operations by creating a fresh X86 variable, populating it, and then applying the in-place arithmetic operation to the variable.
So, we write handler as follows:
\begin{alignat*}{2}
  & \mathbf{handle} && \\
  & \quad(\mathit{add}~x~y) &&~k \to \mathit{x86var} \bind{z} \mathit{movq}~x~z \then \mathit{addq}~y~z \then k~z \\
  & \quad(\mathit{sub}~x~y) &&~k \to \mathit{x86var} \bind{z} \mathit{movq}~x~z \then \mathit{subq}~y~z \then k~z \\
  & \quad(\mathit{neg}~x) &&~k \to \mathit{x86var} \bind{z} \mathit{movq}~x~z \then \mathit{negq}~z \then k~z
\end{alignat*}
The $\mathit{read}$ operation requires us to call a function that we will assume is defined in a standard library called $\mathrm{read\_int}$. This function places its output in the $\mathrm{\%rax}$ register, so we have to move it to avoid it being overwritten by other parts of our program.
The full definition of our handler for the Read effect is as follows:
\begin{align*}
  \mathbf{handle}~\mathit{read}~k & \to \mathit{x86var} \bind{z} \mathit{callq}~\mathrm{read\_int} \then \mathit{reg}~\mathrm{\%rax} \bind{x} \mathit{movq}~x~z \then k~z
\end{align*}

The final challenge to complete this minimal compiler pipeline is to allocate the X86 variables on the stack.
Conceptually, this requires us to give each $\mathit{x86var}$ operation and give each its own location of the stack.
Keeping track of such information in our handler, however, is something we have not yet needed to do for the passes up to this point.
Until now, we have handled each effect by translating into other effects directly.
Instead, we can parameterize our handlers which means we pass along an extra parameter while handling our operations.
Parameterized handlers take one extra parameter and need to pass one extra argument to the continuation\footnote{We ignore effectful subcomputations, because they were already removed in an earlier pass.}. 
Now we can write the parameterized handler for the X86Var effect which assigns each variable to its own stack location as follows:
\begin{align*}
  \mathbf{handle}~\mathit{x86var}~k~n \to \mathit{deref}~\mathrm{\%rbp}~(-8 \cdot n) \bind{z} k~z~(n + 1)
\end{align*}
Note that we assume sufficient space is allocated on the stack.
Additionally, when applying this handler we need to provide the starting value of the parameter $n$, which we will choose to be $1$.

At this point, we have a full compiler pipeline from our source language to a subset of X86, but is still in the form of an effectful computation.
To get a concrete representation, we implement two handlers for the remaining Int and X86 effects to produce an output string.
As part of choosing this concrete representation, we also choose the concrete type for the variables $\mathit{val}$ and $\mathit{lab}$ to be the string type.
We define the handler that turns our effectful computation of Int and X86 effects into a concrete string representation as follows:
\begin{alignat*}{2}
  & \mathbf{handle} && \\
  & \quad(\mathit{int}~n)~&& k \to k~(\mathrm{showInt}~n) \\
  & \quad(\mathit{addq}~x~y)~&& k \to \texttt{"addq "} \append x \append \texttt{", "} \append y \append \texttt{"\textbackslash{}n"} \append k~() \\
  & \quad(\mathit{subq}~x~y)~&& k \to \texttt{"subq "} \append x \append \texttt{", "} \append y \append \texttt{"\textbackslash{}n"} \append k~() \\
  & \quad(\mathit{negq}~x)~&& k \to \texttt{"negq "} \append x \append \texttt{"\textbackslash{}n"} \append k~() \\
  & \quad(\mathit{movq}~x~y)~&& k \to \texttt{"movq "} \append x \append \texttt{", "} \append y \append \texttt{"\textbackslash{}n"} \append k~() \\
  & \quad(\mathit{callq}~l)~&& k \to \texttt{"callq "} \append l \append \texttt{"\textbackslash{}n"} \append k~() \\
  & \quad(\mathit{reg}~r)~&& k \to k~(\mathrm{showReg}~r) \\
  & \quad(\mathit{deref}~r~n)~&& k \to k~(\mathrm{showInt}~n \append \texttt{"("} \append \mathrm{showReg}~r \append \texttt{")"}) \\
  & \quad\mathit{return}~x~&& \hspace{0.55em}\to x 
\end{alignat*}

% The main problem is that we need to pass a valid value as input to the continuation of each operation to get access to the operations in the continuation.
% When the type of the argument of the continuation is a unit type, such as for the X86 arithmetic, move, and call instructions, then we can simply construct the unit value and pass that to the continuation.
% However, if we allow arbitrary concrete types as results of our operations then there is no guarantee that we can construct a value of that type and it is not always possible to reconstruct the higher-order representation if we do manage to construct such a value.
% 
% Luckily, we have chosen to keep our value type abstract.
% So, we still have a choice to instantiate it to a type that suits our purpose.
% Instantiating it to the unit type would make it possible for us to construct a value to pass to the continuation.
% However, we would no longer be able to distinguish values passed to different continuations, so it would not be possible to reconstruct a higher order representation for further manipulation.
% Instead, our solution is to instantiate it to the type of natural numbers and to pass a unique number to each continuation.
% Whenever we encounter such a natural number in the rest of the program, we know which continuation it originated from.
% Hence, we are able to reconstruct a higher order operation.
% 
% This process sounds complicated, but we expect it is possible to expose the ability to keep track of the required information through an easy to use API. 


% booleans and conditionals:
%
% denote (And x y) = do
% x' <- denote x
% if x (denote y) false
%
% handle
% (if b x y) k ->
%   l <- x86lab
%   z <- x86var
%   cmpq b 0
%   jne l
%   x' <- x
%   movq x' z
%   block l
%   y' <- y
%   movq y' z


\section{Related Work}\label{sec:related}

Our work is influenced by Eelco Visser's work on the Spoofax Language Workbench~\cite{10.1145/1869459.1869497}. 
Eelco Visser was the original designer of the Stratego program transformation language~\cite{10.1007/3-540-45127-7_27} which is part of Spoofax. 
Stratego can be used to implement a whole compiler back end, however Spoofax was still lacking a way to specifying programming language semantics at a higher level of abstraction.

One step in that direction by Vlad Vergu, Pierre Neron, and Eelco Visser was the DynSem DSL for dynamic semantics specification~\cite{vergu_et_al:LIPIcs:2015:5208}.
Later, Vlad Vergu and Eelco Visser developed a way to improve the performance of programs written in languages specified in DynSem by using just-in-time compilation~\cite{10.1145/3237009.3237018}.
However, they were not able to fully eliminate the interpretation overhead that DynSem imposes.
Furthermore, DynSem uses big-step operational reduction rules, which require explicit managing of the control flow.
For languages which include complicated control flow constructs, such as exceptions, this requires non-trivial glue code in every reduction rule.

In the meantime, Eelco Visser started working on adding type systems to Spoofax.
Firstly, together with Van Antwerpen et al., he developed Statix~\cite{10.1145/3276484}, which is a language for defining the static semantics of languages defined in Spoofax.
Later, Eelco Visser and Jeff Smits added a gradual type system to the meta-language Stratego~\cite{10.1145/3426425.3426928}.

Recently, Thijs Molendijk, who was supervised by Eelco Visser, has developed the Dynamix~\cite{dynamix} dynamic semantics specification language for Spoofax.
Dynamix is more amenable to compilation and it allows for specifying the semantics of complicated control flow constructs independently from other language constructs.
The monadic style of Dynamix makes it similar to our work, but the main difference is that Dynamix has a fixed intermediate representation where the only way to extend it is to add new primitives.

As mentioned in the introduction, our approach embraces the nanopass architecture~\cite{10.1145/1016850.1016878, 10.1145/2544174.2500618}.
The main idea of nanopass compilers is that they consist of many small single purpose passes, which aids understanding.
We improve upon this work by making it fully typed to prevent common errors and even check that all cases are covered, and by abstracting over the control flow in the compiler.

% Our semantics-driven approach using an effect system is inspired by the work on symbolic execution by Wei et al.~\cite{10.1145/3428232}.


% (TODO)
% 
% \begin{itemize}
%   \item LLVM is a very specific language unsuitable for higher level optimizations of functional programming languages; MLIR allows specification of seemingly arbitrary intermediate representations however you'd again have to write large parts of your compiler from scratch.
%   \item Attribute Grammars / Data Types a la Carte / Object Algebras, 
%   \item Tagless-final can probably do a very similar things, but we expect it will run into the same major issues. It is not clear that a tagless final embedding of our ideas would have a particular advantage over our current approach using higher-order effects.
%   \item MSOS / CBS / funcons / K framework, these approaches are great for specifying the dynamic semantics of programming languages, however, they cannot be used as an implementation of a practical compiler.
%   \item Partial evaluation / Futamura / Truffle and GraalVM, it is still an open problem if partial evaluation can be done in such a way that compiler developers have enough control over the optimization process to produce a practical optimizing compiler.
%   \item Stratego
%   \item ITrees is a lightweight compiler verification method using algebraic effects, we hope to adopt their ideas into our methodology.
%   \item CompCert is a huge specialized compiler achieving formal verification, but at the cost of an enormous development effort.
%   \item The nanopass compiler architecture shares many of the properties of our approach. However, our approach is able to abstract over control flow and our approach has stronger type safety guarantees.
% \end{itemize}

\section{Conclusions and Future Work}\label{sec:conclusion}

We have presented a new semantics-driven approach to writing compilers by using effect operations as an intermediate representation.
We use effect handlers to iteratively refine operations in terms of increasingly lower level operations to finally reach a target machine language.

We have shown a concrete example of this approach applied to a very simple language with arithmetic and let-bound variables.
This example application consists of an implementation of a denotation function and handlers which compile this language is compiled in several passes to X86 machine language.

In the future, we would like to extend this minimal compiler with more complicated language constructs such as conditionals, exceptions, and anonymous functions.

Additionally, we would like to implement more complicated analyses on this effectful representation, such as register allocation.
We expect these analyses to consist of two stages: first derive concrete structures such as control-flow graphs and interference graphs from our effectful representation, and then perform a pass over the effectful computation that uses the results of the analysis over these structures to transform the program.
The first stage would be similar to our handler that turns the effectful computation into a concrete string and the second stage would employ a parameterized handler similar to our stack allocation handler.

Furthermore, we would like to explore the verification of our compilers using algebraic laws for our effect operations, inspired by Interaction Trees~\cite{10.1145/3371119}.
To be specific, we can define a set of laws that describe the behavior of each of the effects in our compiler pipeline.
If these laws are sound and complete, with respect to for example definitional interpreters for the effects, then we can prove compiler correctness by proving that these laws are preserved by each of our handlers.


%%
%% Bibliography
%%

%% Please use bibtex, 

\bibliography{references}

\end{document}

% \section{Typesetting instructions -- Summary}
% \label{sec:typesetting-summary}


% OASIcs is a series of open access high-quality conference proceedings across all fields in informatics established in cooperation with Schloss Dagstuhl. 
% In order to do justice to the high scientific quality of the conferences that publish their proceedings in the OASIcs series, which is ensured by the thorough review process of the respective events, we believe that OASIcs proceedings must have an attractive and consistent layout matching the standard of the series.
% Moreover, the quality of the metadata, the typesetting and the layout must also meet the requirements of other external parties such as indexing service, DOI registry, funding agencies, among others. The guidelines contained in this document serve as the baseline for the authors, editors, and the publisher to create documents that meet as many different requirements as possible. 

% Please comply with the following instructions when preparing your article for a OASIcs proceedings volume. 
% \paragraph*{Minimum requirements}

% \begin{itemize}
% \item Use pdflatex and an up-to-date \LaTeX{} system.
% \item Use further \LaTeX{} packages and custom made macros carefully and only if required.
% \item Use the provided sectioning macros: \verb+\section+, \verb+\subsection+, \verb+\subsubsection+, \linebreak \verb+\paragraph+, \verb+\paragraph*+, and \verb+\subparagraph*+.
% \item Provide suitable graphics of at least 300dpi (preferably in PDF format).
% \item Use BibTeX and keep the standard style (\verb+plainurl+) for the bibliography.
% \item Please try to keep the warnings log as small as possible. Avoid overfull \verb+\hboxes+ and any kind of warnings/errors with the referenced BibTeX entries.
% \item Use a spellchecker to correct typos.
% \end{itemize}

% \paragraph*{Mandatory metadata macros}
% Please set the values of the metadata macros carefully since the information parsed from these macros will be passed to publication servers, catalogues and search engines.
% Avoid placing macros inside the metadata macros. The following metadata macros/environments are mandatory:
% \begin{itemize}
% \item \verb+\title+ and, in case of long titles, \verb+\titlerunning+.
% \item \verb+\author+, one for each author, even if two or more authors have the same affiliation.
% \item \verb+\authorrunning+ and \verb+\Copyright+ (concatenated author names)\\
% The \verb+\author+ macros and the \verb+\Copyright+ macro should contain full author names (especially with regard to the first name), while \verb+\authorrunning+ should contain abbreviated first names.
% \item \verb+\ccsdesc+ (ACM classification, see \url{https://www.acm.org/publications/class-2012}).
% \item \verb+\keywords+ (a comma-separated list of keywords).
% \item \verb+\relatedversion+ (if there is a related version, typically the ``full version''); please make sure to provide a persistent URL, e.\,g., at arXiv.
% \item \verb+\begin{abstract}...\end{abstract}+ .
% \end{itemize}

% \paragraph*{Please do not \ldots} %Do not override the \texttt{\seriesstyle}-defaults}
% Generally speaking, please do not override the \texttt{oasics-v2021}-style defaults. To be more specific, a short checklist also used by Dagstuhl Publishing during the final typesetting is given below.
% In case of \textbf{non-compliance} with these rules Dagstuhl Publishing will remove the corresponding parts of \LaTeX{} code and \textbf{replace it with the \texttt{oasics-v2021} defaults}. In serious cases, we may reject the LaTeX-source and expect the corresponding author to revise the relevant parts.
% \begin{itemize}
% \item Do not use a different main font. (For example, the \texttt{times} package is forbidden.)
% \item Do not alter the spacing of the \texttt{oasics-v2021.cls} style file.
% \item Do not use \verb+enumitem+ and \verb+paralist+. (The \texttt{enumerate} package is preloaded, so you can use
%  \verb+\begin{enumerate}[(a)]+ or the like.)
% \item Do not use ``self-made'' sectioning commands (e.\,g., \verb+\noindent{\bf My+ \verb+Paragraph}+).
% \item Do not hide large text blocks using comments or \verb+\iffalse+ $\ldots$ \verb+\fi+ constructions. 
% \item Do not use conditional structures to include/exclude content. Instead, please provide only the content that should be published -- in one file -- and nothing else.
% \item Do not wrap figures and tables with text. In particular, the package \texttt{wrapfig} is not supported.
% \item Do not change the bibliography style. In particular, do not use author-year citations. (The
% \texttt{natbib} package is not supported.)
% \end{itemize}

% \enlargethispage{\baselineskip}

% This is only a summary containing the most relevant details. Please read the complete document ``OASIcs: Instructions for Authors and the \texttt{oasics-v2021} Class'' for all details and don't hesitate to contact Dagstuhl Publishing (\url{mailto:publishing@dagstuhl.de}) in case of questions or comments:
% 	\href{http://drops.dagstuhl.de/styles/oasics-v2021/oasics-v2021-authors/oasics-v2021-authors-guidelines.pdf}{\texttt{http://drops.dagstuhl.de/styles/oasics-v2021/\newline oasics-v2021-authors/oasics-v2021-authors-guidelines.pdf}}

% \section{Lorem ipsum dolor sit amet}

% Lorem ipsum dolor sit amet, consectetur adipiscing elit \cite{DBLP:journals/cacm/Knuth74}. Praesent convallis orci arcu, eu mollis dolor. Aliquam eleifend suscipit lacinia. Maecenas quam mi, porta ut lacinia sed, convallis ac dui. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse potenti. Donec eget odio et magna ullamcorper vehicula ut vitae libero. Maecenas lectus nulla, auctor nec varius ac, ultricies et turpis. Pellentesque id ante erat. In hac habitasse platea dictumst. Curabitur a scelerisque odio. Pellentesque elit risus, posuere quis elementum at, pellentesque ut diam. Quisque aliquam libero id mi imperdiet quis convallis turpis eleifend. 

% \begin{lemma}[Lorem ipsum]
% \label{lemma:lorem}
% Vestibulum sodales dolor et dui cursus iaculis. Nullam ullamcorper purus vel turpis lobortis eu tempus lorem semper. Proin facilisis gravida rutrum. Etiam sed sollicitudin lorem. Proin pellentesque risus at elit hendrerit pharetra. Integer at turpis varius libero rhoncus fermentum vitae vitae metus.
% \end{lemma}

% \begin{proof}
% Cras purus lorem, pulvinar et fermentum sagittis, suscipit quis magna.


% \proofsubparagraph*{Just some paragraph within the proof.}
% Nam liber tempor cum soluta nobis eleifend option congue nihil imperdiet doming id quod mazim placerat facer possim assum. Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat.
% \begin{claim}
% content...
% \end{claim}
% \begin{claimproof}
% content...
%     \begin{enumerate}
%         \item abc abc abc \claimqedhere{}
%     \end{enumerate}
% \end{claimproof}

% \end{proof}

% \begin{corollary}[Curabitur pulvinar, \cite{DBLP:books/mk/GrayR93}]
% \label{lemma:curabitur}
% Nam liber tempor cum soluta nobis eleifend option congue nihil imperdiet doming id quod mazim placerat facer possim assum. Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat.
% \end{corollary}

% \begin{proposition}\label{prop1}
% This is a proposition
% \end{proposition}

% \autoref{prop1} and \cref{prop1} \ldots

% \subsection{Curabitur dictum felis id sapien}

% Curabitur dictum \cref{lemma:curabitur} felis id sapien \autoref{lemma:curabitur} mollis ut venenatis tortor feugiat. Curabitur sed velit diam. Integer aliquam, nunc ac egestas lacinia, nibh est vehicula nibh, ac auctor velit tellus non arcu. Vestibulum lacinia ipsum vitae nisi ultrices eget gravida turpis laoreet. Duis rutrum dapibus ornare. Nulla vehicula vulputate iaculis. Proin a consequat neque. Donec ut rutrum urna. Morbi scelerisque turpis sed elit sagittis eu scelerisque quam condimentum. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Aenean nec faucibus leo. Cras ut nisl odio, non tincidunt lorem. Integer purus ligula, venenatis et convallis lacinia, scelerisque at erat. Fusce risus libero, convallis at fermentum in, dignissim sed sem. Ut dapibus orci vitae nisl viverra nec adipiscing tortor condimentum \cite{DBLP:journals/cacm/Dijkstra68a}. Donec non suscipit lorem. Nam sit amet enim vitae nisl accumsan pretium. 

% \begin{lstlisting}[caption={Useless code.},label=list:8-6,captionpos=t,float,abovecaptionskip=-\medskipamount]
% for i:=maxint to 0 do 
% begin 
%     j:=square(root(i));
% end;
% \end{lstlisting}

% \subsection{Proin ac fermentum augue}

% Proin ac fermentum augue. Nullam bibendum enim sollicitudin tellus egestas lacinia euismod orci mollis. Nulla facilisi. Vivamus volutpat venenatis sapien, vitae feugiat arcu fringilla ac. Mauris sapien tortor, sagittis eget auctor at, vulputate pharetra magna. Sed congue, dui nec vulputate convallis, sem nunc adipiscing dui, vel venenatis mauris sem in dui. Praesent a pretium quam. Mauris non mauris sit amet eros rutrum aliquam id ut sapien. Nulla aliquet fringilla sagittis. Pellentesque eu metus posuere nunc tincidunt dignissim in tempor dolor. Nulla cursus aliquet enim. Cras sapien risus, accumsan eu cursus ut, commodo vel velit. Praesent aliquet consectetur ligula, vitae iaculis ligula interdum vel. Integer faucibus faucibus felis. 

% \begin{itemize}
% \item Ut vitae diam augue. 
% \item Integer lacus ante, pellentesque sed sollicitudin et, pulvinar adipiscing sem. 
% \item Maecenas facilisis, leo quis tincidunt egestas, magna ipsum condimentum orci, vitae facilisis nibh turpis et elit. 
% \end{itemize}

% \begin{remark}
% content...
% \end{remark}

% \section{Pellentesque quis tortor}

% Nec urna malesuada sollicitudin. Nulla facilisi. Vivamus aliquam tempus ligula eget ornare. Praesent eget magna ut turpis mattis cursus. Aliquam vel condimentum orci. Nunc congue, libero in gravida convallis \cite{DBLP:conf/focs/HopcroftPV75}, orci nibh sodales quam, id egestas felis mi nec nisi. Suspendisse tincidunt, est ac vestibulum posuere, justo odio bibendum urna, rutrum bibendum dolor sem nec tellus. 

% \begin{lemma} [Quisque blandit tempus nunc]
% Sed interdum nisl pretium non. Mauris sodales consequat risus vel consectetur. Aliquam erat volutpat. Nunc sed sapien ligula. Proin faucibus sapien luctus nisl feugiat convallis faucibus elit cursus. Nunc vestibulum nunc ac massa pretium pharetra. Nulla facilisis turpis id augue venenatis blandit. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus.
% \end{lemma}

% Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.

% \section{Morbi eros magna}

% Morbi eros magna, vestibulum non posuere non, porta eu quam. Maecenas vitae orci risus, eget imperdiet mauris. Donec massa mauris, pellentesque vel lobortis eu, molestie ac turpis. Sed condimentum convallis dolor, a dignissim est ultrices eu. Donec consectetur volutpat eros, et ornare dui ultricies id. Vivamus eu augue eget dolor euismod ultrices et sit amet nisi. Vivamus malesuada leo ac leo ullamcorper tempor. Donec justo mi, tempor vitae aliquet non, faucibus eu lacus. Donec dictum gravida neque, non porta turpis imperdiet eget. Curabitur quis euismod ligula. 


% %%
% %% Bibliography
% %%

% %% Please use bibtex, 

% \bibliography{src/references}

% \appendix

% \section{Styles of lists, enumerations, and descriptions}\label{sec:itemStyles}

% List of different predefined enumeration styles:

% \begin{itemize}
% \item \verb|\begin{itemize}...\end{itemize}|
% \item \dots
% \item \dots
% %\item \dots
% \end{itemize}

% \begin{enumerate}
% \item \verb|\begin{enumerate}...\end{enumerate}|
% \item \dots
% \item \dots
% %\item \dots
% \end{enumerate}

% \begin{alphaenumerate}
% \item \verb|\begin{alphaenumerate}...\end{alphaenumerate}|
% \item \dots
% \item \dots
% %\item \dots
% \end{alphaenumerate}

% \begin{romanenumerate}
% \item \verb|\begin{romanenumerate}...\end{romanenumerate}|
% \item \dots
% \item \dots
% %\item \dots
% \end{romanenumerate}

% \begin{bracketenumerate}
% \item \verb|\begin{bracketenumerate}...\end{bracketenumerate}|
% \item \dots
% \item \dots
% %\item \dots
% \end{bracketenumerate}

% \begin{description}
% \item[Description 1] \verb|\begin{description} \item[Description 1]  ...\end{description}|
% \item[Description 2] Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
% \item[Description 3]  \dots
% %\item \dots
% \end{description}

% \cref{testenv-proposition} and \autoref{testenv-proposition} ...

% \section{Theorem-like environments}\label{sec:theorem-environments}

% List of different predefined enumeration styles:

% \begin{theorem}\label{testenv-theorem}
% Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
% \end{theorem}

% \begin{lemma}\label{testenv-lemma}
% Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
% \end{lemma}

% \begin{corollary}\label{testenv-corollary}
% Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
% \end{corollary}

% \begin{proposition}\label{testenv-proposition}
% Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
% \end{proposition}

% \begin{conjecture}\label{testenv-conjecture}
% Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
% \end{conjecture}

% \begin{observation}\label{testenv-observation}
% Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
% \end{observation}

% \begin{exercise}\label{testenv-exercise}
% Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
% \end{exercise}

% \begin{definition}\label{testenv-definition}
% Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
% \end{definition}

% \begin{example}\label{testenv-example}
% Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
% \end{example}

% \begin{note}\label{testenv-note}
% Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
% \end{note}

% \begin{note*}
% Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
% \end{note*}

% \begin{remark}\label{testenv-remark}
% Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
% \end{remark}

% \begin{remark*}
% Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
% \end{remark*}

% \begin{claim}\label{testenv-claim}
% Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
% \end{claim}

% \begin{claim*}\label{testenv-claim2}
% Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
% \end{claim*}

% \begin{proof}
% Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
% \end{proof}

% \begin{claimproof}
% Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
% \end{claimproof}

% \end{document}
