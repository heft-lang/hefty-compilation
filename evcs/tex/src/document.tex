
\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate, anonymous]{oasics-v2021}
%This is a template for producing OASIcs articles. 
%See oasics-v2021-authors-guidelines.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling autoref support, use "autoref"
%for anonymousing the authors (e.g. for double-blind review), add "anonymous"
%for enabling thm-restate support, use "thm-restate"
%for enabling a two-column layout for the author/affilation part (only applicable for > 6 authors), use "authorcolumns"
%for producing a PDF according the PDF/A standard, add "pdfa"

%\pdfoutput=1 %uncomment to ensure pdflatex processing (mandatatory e.g. to submit to arXiv)
%\hideOASIcs %uncomment to remove references to OASIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{Towards Modular Compilation using Higher-order Effects}

\author{Jaro Sam Reinders}{Delft University of Technology, Netherlands}{j.s.reinders@tudelft.nl}{https://orcid.org/0000-0002-6837-3757}{} % (Optional) author-specific funding acknowledgements}

\authorrunning{J.S. Reinders}

\Copyright{Jaro Sam Reinders}

\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10003752.10010124.10010131</concept_id>
<concept_desc>Theory of computation~Program semantics</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10011007.10011006.10011041</concept_id>
<concept_desc>Software and its engineering~Compilers</concept_desc>
<concept_significance>500</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Program semantics}
\ccsdesc[500]{Software and its engineering~Compilers}

\keywords{algebraic effects and handlers, higher-order effects, monadic semantics, modularity, compilation, nanopass}

% \category{} %optional, e.g. invited paper

% \relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversiondetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93]{Classification (e.g. Full Version, Extended Version, Previous Version}{URL to related version} %linktext and cite are optional

%\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...
%\supplementdetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93, subcategory={Description, Subcategory}, swhid={Software Heritage Identifier}]{General Classification (e.g. Software, Dataset, Model, ...)}{URL to related version} %linktext, cite, and subcategory are optional

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

% \acknowledgements{I want to thank \dots}%optional

%\nolinenumbers %uncomment to disable line numbering

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand\bind[1]{>\!\!>\!\!= \lambda #1.\,}
\newcommand\then{>\!\!>}


\begin{document}

\maketitle

\begin{abstract}
  Compilers transform a human readable source language into machine readable target language.
  Nanopass compilers simplify this approach by breaking up this transformation into small steps that are more understandable, maintainable, and extensible.
  We propose a semantics-driven variant of the nanopass compiler architecture exploring the use a effects and handlers to model the intermediate languages and the transformation passes, respectively.
  Our approach is fully typed and ensures that all cases in the compiler are covered.
  Additionally, by using an effect system we abstract over the control flow of the intermediate language making the compiler even more flexible.
  We apply this approach to a minimal compiler from a language with arithmetic and let-bound variables to a minimal subset of X86 machine code with variables.
  In the future, we hope to extend this work to compile a larger and more complicated language and we envision a formal verification framework from compilers written in this style.
\end{abstract}

\section{Introduction}

The essence of a compiler is a function from a source language, suitable for humans, to a machine language, suitable for computers.
As our computers have become more powerful we have seen increasingly complex compilers providing extensive safety guarantees and powerful optimizations.
To manage this complexity, modern compilers are designed as a composition of multiple passes.
However, the total number of passes has traditionally been kept low for the sake of performance, because each pass adds extra overhead.
Thus, compiler passes are more complicated than necessary and therefore harder to \emph{understand}, \emph{maintain}, and \emph{extend}.

To address this problem, Sarkar, Waddell, and Dybvig \cite{10.1145/1016850.1016878} introduce the nanopass compiler architecture.
In the nanopass architecture, each pass is designed to be as simple as possible.
It is not a problem to use many more passes than are used in traditional compilers. 
To address concerns about the performance of this architecture, Keep and Dybvig \cite{10.1145/2544174.2500618} show that it is possible to write a competitive commercial compiler using this architecture.

While the development of the nanopass architecture and the development of a commercial compiler is a great engineering achievement, we believe the theoretical foundation is underexplored.
In this paper, we present our ongoing work on developing a semantics-driven nanopass compiler architecture.
Our approach has the practical advantage of preventing type errors in the compiler and ensuring all cases are covered.
Additionally, our approach abstracts over the control flow giving many of the benefits of continuation-passing-style while retaining a simple monadic interface.
During the development of our approach, we are anticipating the possibility of verifying the correctness of compilers written in this style.

\noindent
Concretely, we make the following contributions:
\begin{itemize}
  \item We introduce a novel approach to designing and implementing practical compilers while staying close to formal denotational semantics specifications (Section~\ref{sec:compiling}). 
  \item We demonstrate our approach on a simple language with arithmetic and let-bound variables (Section~\ref{sec:compiling}). We compile this language to a subset of X86 with variables. We are still working a method to allocate these variables on the stack.
\end{itemize}

\section{Compiling with Higher-order Effects}\label{sec:compiling}

In this section, we present our approach by applying it to a very simple language with arithmetic and let-bound variables.
The target language of our compiler is X86 machine code.
We explain the required concepts as we develop our compiler for this language.
The specifications and compiler passes are presented in a simplified notation, but we have implemented all the work we present here in the Agda programming language~\cite{10.1007/978-3-642-03359-9_6}.

We start off by assuming our parser and possibly type checker has finished and produced an abstract syntax tree which follows the grammar described in Figure~\ref{fig:source-absyn}.
Our language has integers, addition, subtraction, negation, a read operation to read an input integer, and a let to bind variables and a var to refer to bound variables.
The abstract syntax is unusual because we reuse the variable binding facilities from our host language in the form of the $\lambda x.$ binding in the let constructor.
This style of abstract syntax is called parametric higher-order abstract syntax (PHOAS) \cite{10.1145/1411203.1411226}.
It allows us to avoid the complexities of variable binding and thus simplify our presentation.

\begin{figure}[ht]
  \begin{align*}
    \mathit{expr} ::= &\ \mathrm{int}(n) \\
           | &\ \mathrm{add}(\mathit{expr},\mathit{expr}) \\
           | &\ \mathrm{sub}(\mathit{expr},\mathit{expr}) \\
           | &\ \mathrm{neg}(\mathit{expr}) \\
           | &\ \mathrm{read} \\
           | &\ \mathrm{let}(\mathit{expr},\lambda \mathit{x}.\,\mathit{expr}) \\
           | &\ \mathrm{var}(\mathit{x})
  \end{align*}
  \caption{Abstract syntax of our simple language with arithmetic and let-bound variables.}\label{fig:source-absyn}
\end{figure}

The first step of our compilation pipeline will be to denote these syntactic constructs onto a set of semantic algebraic operations in the sense of algebraic effects~\cite{10.1007/3-540-45315-6_1}.
As is customary when using algebraic effects in functional programming languages, we group these operations under units we call effects.
We could group every operation under a single effect, however with the benefit of hindsight we decide to distribute the operations over four effects: Int, Arith, Read, and Let.

\begin{figure}[ht]
\begin{minipage}{0.4\textwidth}
\begin{alignat*}{2}
  \mathit{int} & : \mathbb{Z} && \to m~\mathit{val}
\end{alignat*}

\begin{alignat*}{2}
  \mathit{add} & : \mathit{val} \to \mathit{val} && \to m~\mathit{val} \\
  \mathit{sub} & : \mathit{val} \to \mathit{val} && \to m~\mathit{val} \\
  \mathit{neg} & : \mathit{val}                  && \to m~\mathit{val}
\end{alignat*}
\end{minipage}%
%
\begin{minipage}{0.6\textwidth}
\begin{alignat*}{2}
  \mathit{read} & : m~\mathit{val}
\end{alignat*}

\begin{alignat*}{2}
  \mathit{let} & : m~\mathit{val} \to (\mathit{val} \to m~\mathit{val}) && \to m~\mathit{val}
\end{alignat*}
\end{minipage}
  \caption{The operations of our source language with their signatures. Divided into the following effects from left to right and then top to bottom: Int, Read, Arith, and Let.}\label{fig:source-ops}
\end{figure}

Figure~\ref{fig:source-ops} shows the operations that correspond directly to our source language.
However, there are some particularities we address individually:
\begin{itemize}
  \item 
    To keep our example simple, we have chosen to use this single type for all values, but we keep the type abstract and simply call it `val'.
    It is crucial to keep this type abstract for reasons we explain at the end of this section.
    Also note that we now need a special $\mathit{int}$ operation to inject integers into this abstract value type.
  \item 
    We write the surrounding monadic context as $m$, which provides the standard $>\!\!>\!\!=$, $>\!\!>$, and $\mathit{return}$ operations.
    The monadic context of each operation always includes at least the effect that the operation belongs to, but it can accomodate other effects too.
    For example, the monadic context of $\mathit{int}~1 \bind{x} \mathit{add}~x~x$ contains at least the Int and Arith effects.
  \item
    Readers knowledgeable about effect systems might notice that the $\mathit{let}$ operation has arguments that are themselves monadic computations.
    In standard algebraic effects and handlers this is not allowed, however our approach uses a novel higher-order effect formalism that does support such effectful subcomputations~\cite{BachPoulsen2022heftyalgebras}.
\end{itemize}

The first pass of our compiler pipeline is to map our abstract syntax from Figure~\ref{fig:source-absyn} onto the operations we have defined for our source language from Figure~\ref{fig:source-ops}.
This mapping, called a denotation and written using the $[\![ \cdot ]\!]$ notation, is a recursive traversal of the abstract syntax tree shown in Figure~\ref{fig:den}.
The result of this mapping is a monadic computation involving the Int, Arith, Read, and Let effects.

\begin{figure}[ht]
\begin{align*}
  [\![ \mathrm{int}(n) ]\!] & = \mathit{int}~n \\
  [\![ \mathrm{add}(e_1, e_2) ]\!] & = [\![ e_1 ]\!] \bind{x} [\![ e_2 ]\!] \bind{y} \mathit{add}~x~y \\
  [\![ \mathrm{sub}(e_1, e_2) ]\!] & = [\![ e_1 ]\!] \bind{x} [\![ e_2 ]\!] \bind{y} \mathit{sub}~x~y \\
  [\![ \mathrm{neg}(e) ]\!] & = [\![ e ]\!] \bind{x} \mathit{neg}~x \\
  [\![ \mathrm{read} ]\!] & = \mathit{read} \\
  [\![ \mathrm{let}(e,f) ]\!] & = \mathit{let}~[\![e]\!]~(\lambda x.\, [\![ f~x ]\!]) \\
  [\![ \mathrm{var}(x) ]\!] & = \mathit{return}~x
\end{align*}
  \caption{Denotational mapping from our abstract syntax onto our initial set of effectful operations.}\label{fig:den}
\end{figure}

Now that we have denoted our syntactic elements into our semantic domain as operations, we can start refining these operations to get closer to the desired target language which is X86 in our case.
In the practice of algebraic effects, this refinement is facillitated by handlers as introduced by Plotkin and Pretnar~\cite{10.1007/978-3-642-00590-9_7}.
These handlers give us access to the operations that occur in the program and the continuation of the program which we will simply call $k$.
We only have to provide the rules that map the operation and continuation onto our semantic domain consisting of primitives, existing operations, or newly introduced operations.

The effect that we choose to handle first is the Let effect, which only has the $\mathit{let}$ operation.
We handle this operation by running the right hand side of the binding, passing the resulting value to the body, and finally passing the result of that to the continuation. In code that looks as follows:
\begin{align*}
  \mathrm{handle}~(\mathit{let}~e~f)~k & = e \bind{x} f~x \bind{z} k~z
\end{align*}
Note that this defines a strict semantics for our let bindings.
By using a different handler we could give different semantics to our language.
This is an example of the flexiblility of algebraic effects and handlers.

\begin{figure}[ht]
  \begin{minipage}{0.4\textwidth}
  \begin{alignat*}{2}
    addq  & : \mathit{val} \to \mathit{val} && \to m~() \\
    subq  & : \mathit{val} \to \mathit{val} && \to m~() \\
    negq  & : \mathit{val}                  && \to m~() \\
    movq  & : \mathit{val} \to \mathit{val} && \to m~() \\
    callq & : \mathit{lab}                  && \to m~() \\
    reg   & : \mathrm{Register}             && \to m~\mathit{val}
  \end{alignat*}
  \end{minipage}
  \begin{minipage}{0.4\textwidth}
  \begin{align*}
    x86var : m~\mathit{val}
  \end{align*}
  \end{minipage}
  \caption{X86 related effects. On the left X86. On the right X86Var.}\label{fig:x86-ops}
\end{figure}

At this point, since our language is so simple we can already begin translating into our target language.
In Figure~\ref{fig:x86-ops} we show the a minimal subset of X86 that we need to compile our Arith and Read effects.
This subset contains in-place arithmetic instructions, the ubiquitous move instruction, the call instruction, and an operation to inject concrete registers into our abstract value type.
Additionally, we add an operation to generate fresh variables and inject them into our abstract value type.

We can trasnlate our Arith effect operations into X86 operations by creating a fresh X86 variable, populating it, and then applying the in-place arithmetic operation to the variable.
So, we write handler as follows:
\begin{alignat*}{2}
  & \mathrm{handle}~(\mathit{add}~x~y) &&~k = x86var \bind{z} \mathit{movq}~x~z \then \mathit{addq}~y~z \then k~z \\
  & \mathrm{handle}~(\mathit{sub}~x~y) &&~k = x86var \bind{z} \mathit{movq}~x~z \then \mathit{subq}~y~z \then k~z \\
  & \mathrm{handle}~(\mathit{add}~x) &&~k = x86var \bind{z} \mathit{movq}~x~z \then \mathit{negq}~z \then k~z
\end{alignat*}
The $\mathit{read}$ operation requires us to call a function that we will assume is defined in a standard library called $\mathrm{read\_int}$. This function places its output in the $\mathrm{\%rax}$ register, so we have to move it to avoid it being overwritten by other parts of our program.
The full definition of our handler for the Read effect is as follows:
\begin{align*}
  \mathrm{handle}~\mathit{read}~k & = x86var \bind{z} \mathit{callq}~\mathrm{read\_int} \then \mathit{reg}~\mathrm{\%rax} \bind{x} \mathit{movq}~x~z \then k~z
\end{align*}

The final challenge to complete this minimal compiler is to allocate the X86 variables on the stack.
Conceptually, this requires us to give each $\mathit{x86var}$ operation and give each its own location of the stack.
Keeping track of such information in our handler, however, is something we have not yet needed to do for the passes up to this point.
The main problem is that we need to pass a valid value as input to the continuation of each operation to get access to the operations in the contination.
When the type of the argument of the contination is a unit type, such as for the X86 arithmetic, move, and call instructions, then we can simply construct the unit value and pass that to the contination.
However, if we allow arbitrary concrete types as results of our operations then there is no guarantee that we can construct a value of that type and it is not always possible to reconstruct the higher-order representation if we do manage to construct such a value.

Luckily, we have chosen to keep our value type abstract.
So, we still have a choice to instantiate it to a type that suits our purpose.
Instantiating it to the unit type would make it possible for us to construct a value to pass to the continuation.
However, we would no longer be able to distinguish values passed to different continuations, so it would not be possible to reconstruct a higher order representation for further manipulation.
Instead, our solution is to instatiate it to the type of natural numbers and to pass a unique number to each continuation.
Whenever we encounter such a natural number in the rest of the program, we know which continuation it originated from.
Hence, we are able to reconstruct a higher order operation.

This process sounds complicated, but we expect it is possible to expose the ability to keep track of the required information through an easy to use API. 

\section{Related Work}\label{sec:related}

The origins of this work can be traced back to Eelco Visser's work on the Spoofax Language Workbench~\cite{6898704}. 
As part of Spoofax, Eelco is one of the designers of the Stratego~\cite{10.1007/3-540-45127-7_27} program transformation language. 
While Stratego can be used for developing compilers, Eelco was still looking for a way of specifying compilers that also abstracts over the control flow.
We hope that this work can be the start of an answer to that research direction.

As mentioned in the introduction, our approach embraces the nanopass architecture \cite{10.1145/1016850.1016878, 10.1145/2544174.2500618}.
We improve upon this work by putting it on more formal foundations, making it fully typed to prevent common errors and even check that all cases are covered, and abstracting over the control flow in the compiler.

Our semantics-driven approach using an effect system is inspired by the work on symbolic execution by Wei et al.~\cite{10.1145/3428232}.

For our vision on verification of compilers we have taken inspiration from Interaction Trees~\cite{10.1145/3371119}.
Interaction Trees use algebraic laws of effects to prove the correctness of compilers.
We hope to learn from that technique to prove the correctness of compilers written using our approach.

% (TODO)
% 
% \begin{itemize}
%   \item LLVM is a very specific language unsuitable for higher level optimizations of functional programming languages; MLIR allows specification of seemingly arbitrary intermediate representations however you'd again have to write large parts of your compiler from scratch.
%   \item Attribute Grammars / Data Types a la Carte / Object Algebras, 
%   \item Tagless-final can probably do a very similar things, but we expect it will run into the same major issues. It is not clear that a tagless final embedding of our ideas would have a particular advantage over our current approach using higher-order effects.
%   \item MSOS / CBS / funcons / K framework, these approaches are great for specifying the dynamic semantics of programming languages, however, they cannot be used as an implementation of a practical compiler.
%   \item Partial evaluation / Futamura / Truffle and GraalVM, it is still an open problem if partial evaluation can be done in such a way that compiler developers have enough control over the optimization process to produce a practical optimizing compiler.
%   \item Stratego
%   \item ITrees is a lightweight compiler verification method using algebraic effects, we hope to adopt their ideas into our methodology.
%   \item CompCert is a huge specialized compiler achieving formal verification, but at the cost of an enormous development effort.
%   \item The nanopass compiler architecture shares many of the properties of our approach. However, our approach is able to abstract over control flow and our approach has stronger type safety guarantees.
% \end{itemize}

\section{Conclusions and Future Work}\label{sec:conclusion}

We have presented a new semantics-driven approach to writing compilers by using effect operations as an intermediate representation.
We use effect handlers to iteratively refine operations in terms of increasingly lower level operations to finally reach a target machine language.

We have shown a concrete example of this approach applied to a very simple language with arithmetic and let-bound variables.
We show the implementation of a denotation function and handlers which compile this language is compiled in several passes to X86 machine language with variables.
Currently, we are working on a stack allocation pass to complete this minimal compiler.

In the future, we would like to complete the minimal compiler and extend it with more complicated language constructs such as conditionals and anonymous functions.
Furthermore, we would like to explore the verification of our compilers using algebraic laws for our effect operations.

%%
%% Bibliography
%%

%% Please use bibtex, 

\bibliography{src/references}

\end{document}

\section{Typesetting instructions -- Summary}
\label{sec:typesetting-summary}


OASIcs is a series of open access high-quality conference proceedings across all fields in informatics established in cooperation with Schloss Dagstuhl. 
In order to do justice to the high scientific quality of the conferences that publish their proceedings in the OASIcs series, which is ensured by the thorough review process of the respective events, we believe that OASIcs proceedings must have an attractive and consistent layout matching the standard of the series.
Moreover, the quality of the metadata, the typesetting and the layout must also meet the requirements of other external parties such as indexing service, DOI registry, funding agencies, among others. The guidelines contained in this document serve as the baseline for the authors, editors, and the publisher to create documents that meet as many different requirements as possible. 

Please comply with the following instructions when preparing your article for a OASIcs proceedings volume. 
\paragraph*{Minimum requirements}

\begin{itemize}
\item Use pdflatex and an up-to-date \LaTeX{} system.
\item Use further \LaTeX{} packages and custom made macros carefully and only if required.
\item Use the provided sectioning macros: \verb+\section+, \verb+\subsection+, \verb+\subsubsection+, \linebreak \verb+\paragraph+, \verb+\paragraph*+, and \verb+\subparagraph*+.
\item Provide suitable graphics of at least 300dpi (preferably in PDF format).
\item Use BibTeX and keep the standard style (\verb+plainurl+) for the bibliography.
\item Please try to keep the warnings log as small as possible. Avoid overfull \verb+\hboxes+ and any kind of warnings/errors with the referenced BibTeX entries.
\item Use a spellchecker to correct typos.
\end{itemize}

\paragraph*{Mandatory metadata macros}
Please set the values of the metadata macros carefully since the information parsed from these macros will be passed to publication servers, catalogues and search engines.
Avoid placing macros inside the metadata macros. The following metadata macros/environments are mandatory:
\begin{itemize}
\item \verb+\title+ and, in case of long titles, \verb+\titlerunning+.
\item \verb+\author+, one for each author, even if two or more authors have the same affiliation.
\item \verb+\authorrunning+ and \verb+\Copyright+ (concatenated author names)\\
The \verb+\author+ macros and the \verb+\Copyright+ macro should contain full author names (especially with regard to the first name), while \verb+\authorrunning+ should contain abbreviated first names.
\item \verb+\ccsdesc+ (ACM classification, see \url{https://www.acm.org/publications/class-2012}).
\item \verb+\keywords+ (a comma-separated list of keywords).
\item \verb+\relatedversion+ (if there is a related version, typically the ``full version''); please make sure to provide a persistent URL, e.\,g., at arXiv.
\item \verb+\begin{abstract}...\end{abstract}+ .
\end{itemize}

\paragraph*{Please do not \ldots} %Do not override the \texttt{\seriesstyle}-defaults}
Generally speaking, please do not override the \texttt{oasics-v2021}-style defaults. To be more specific, a short checklist also used by Dagstuhl Publishing during the final typesetting is given below.
In case of \textbf{non-compliance} with these rules Dagstuhl Publishing will remove the corresponding parts of \LaTeX{} code and \textbf{replace it with the \texttt{oasics-v2021} defaults}. In serious cases, we may reject the LaTeX-source and expect the corresponding author to revise the relevant parts.
\begin{itemize}
\item Do not use a different main font. (For example, the \texttt{times} package is forbidden.)
\item Do not alter the spacing of the \texttt{oasics-v2021.cls} style file.
\item Do not use \verb+enumitem+ and \verb+paralist+. (The \texttt{enumerate} package is preloaded, so you can use
 \verb+\begin{enumerate}[(a)]+ or the like.)
\item Do not use ``self-made'' sectioning commands (e.\,g., \verb+\noindent{\bf My+ \verb+Paragraph}+).
\item Do not hide large text blocks using comments or \verb+\iffalse+ $\ldots$ \verb+\fi+ constructions. 
\item Do not use conditional structures to include/exclude content. Instead, please provide only the content that should be published -- in one file -- and nothing else.
\item Do not wrap figures and tables with text. In particular, the package \texttt{wrapfig} is not supported.
\item Do not change the bibliography style. In particular, do not use author-year citations. (The
\texttt{natbib} package is not supported.)
\end{itemize}

\enlargethispage{\baselineskip}

This is only a summary containing the most relevant details. Please read the complete document ``OASIcs: Instructions for Authors and the \texttt{oasics-v2021} Class'' for all details and don't hesitate to contact Dagstuhl Publishing (\url{mailto:publishing@dagstuhl.de}) in case of questions or comments:
	\href{http://drops.dagstuhl.de/styles/oasics-v2021/oasics-v2021-authors/oasics-v2021-authors-guidelines.pdf}{\texttt{http://drops.dagstuhl.de/styles/oasics-v2021/\newline oasics-v2021-authors/oasics-v2021-authors-guidelines.pdf}}

\section{Lorem ipsum dolor sit amet}

Lorem ipsum dolor sit amet, consectetur adipiscing elit \cite{DBLP:journals/cacm/Knuth74}. Praesent convallis orci arcu, eu mollis dolor. Aliquam eleifend suscipit lacinia. Maecenas quam mi, porta ut lacinia sed, convallis ac dui. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse potenti. Donec eget odio et magna ullamcorper vehicula ut vitae libero. Maecenas lectus nulla, auctor nec varius ac, ultricies et turpis. Pellentesque id ante erat. In hac habitasse platea dictumst. Curabitur a scelerisque odio. Pellentesque elit risus, posuere quis elementum at, pellentesque ut diam. Quisque aliquam libero id mi imperdiet quis convallis turpis eleifend. 

\begin{lemma}[Lorem ipsum]
\label{lemma:lorem}
Vestibulum sodales dolor et dui cursus iaculis. Nullam ullamcorper purus vel turpis lobortis eu tempus lorem semper. Proin facilisis gravida rutrum. Etiam sed sollicitudin lorem. Proin pellentesque risus at elit hendrerit pharetra. Integer at turpis varius libero rhoncus fermentum vitae vitae metus.
\end{lemma}

\begin{proof}
Cras purus lorem, pulvinar et fermentum sagittis, suscipit quis magna.


\proofsubparagraph*{Just some paragraph within the proof.}
Nam liber tempor cum soluta nobis eleifend option congue nihil imperdiet doming id quod mazim placerat facer possim assum. Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat.
\begin{claim}
content...
\end{claim}
\begin{claimproof}
content...
    \begin{enumerate}
        \item abc abc abc \claimqedhere{}
    \end{enumerate}
\end{claimproof}

\end{proof}

\begin{corollary}[Curabitur pulvinar, \cite{DBLP:books/mk/GrayR93}]
\label{lemma:curabitur}
Nam liber tempor cum soluta nobis eleifend option congue nihil imperdiet doming id quod mazim placerat facer possim assum. Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat.
\end{corollary}

\begin{proposition}\label{prop1}
This is a proposition
\end{proposition}

\autoref{prop1} and \cref{prop1} \ldots

\subsection{Curabitur dictum felis id sapien}

Curabitur dictum \cref{lemma:curabitur} felis id sapien \autoref{lemma:curabitur} mollis ut venenatis tortor feugiat. Curabitur sed velit diam. Integer aliquam, nunc ac egestas lacinia, nibh est vehicula nibh, ac auctor velit tellus non arcu. Vestibulum lacinia ipsum vitae nisi ultrices eget gravida turpis laoreet. Duis rutrum dapibus ornare. Nulla vehicula vulputate iaculis. Proin a consequat neque. Donec ut rutrum urna. Morbi scelerisque turpis sed elit sagittis eu scelerisque quam condimentum. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Aenean nec faucibus leo. Cras ut nisl odio, non tincidunt lorem. Integer purus ligula, venenatis et convallis lacinia, scelerisque at erat. Fusce risus libero, convallis at fermentum in, dignissim sed sem. Ut dapibus orci vitae nisl viverra nec adipiscing tortor condimentum \cite{DBLP:journals/cacm/Dijkstra68a}. Donec non suscipit lorem. Nam sit amet enim vitae nisl accumsan pretium. 

\begin{lstlisting}[caption={Useless code.},label=list:8-6,captionpos=t,float,abovecaptionskip=-\medskipamount]
for i:=maxint to 0 do 
begin 
    j:=square(root(i));
end;
\end{lstlisting}

\subsection{Proin ac fermentum augue}

Proin ac fermentum augue. Nullam bibendum enim sollicitudin tellus egestas lacinia euismod orci mollis. Nulla facilisi. Vivamus volutpat venenatis sapien, vitae feugiat arcu fringilla ac. Mauris sapien tortor, sagittis eget auctor at, vulputate pharetra magna. Sed congue, dui nec vulputate convallis, sem nunc adipiscing dui, vel venenatis mauris sem in dui. Praesent a pretium quam. Mauris non mauris sit amet eros rutrum aliquam id ut sapien. Nulla aliquet fringilla sagittis. Pellentesque eu metus posuere nunc tincidunt dignissim in tempor dolor. Nulla cursus aliquet enim. Cras sapien risus, accumsan eu cursus ut, commodo vel velit. Praesent aliquet consectetur ligula, vitae iaculis ligula interdum vel. Integer faucibus faucibus felis. 

\begin{itemize}
\item Ut vitae diam augue. 
\item Integer lacus ante, pellentesque sed sollicitudin et, pulvinar adipiscing sem. 
\item Maecenas facilisis, leo quis tincidunt egestas, magna ipsum condimentum orci, vitae facilisis nibh turpis et elit. 
\end{itemize}

\begin{remark}
content...
\end{remark}

\section{Pellentesque quis tortor}

Nec urna malesuada sollicitudin. Nulla facilisi. Vivamus aliquam tempus ligula eget ornare. Praesent eget magna ut turpis mattis cursus. Aliquam vel condimentum orci. Nunc congue, libero in gravida convallis \cite{DBLP:conf/focs/HopcroftPV75}, orci nibh sodales quam, id egestas felis mi nec nisi. Suspendisse tincidunt, est ac vestibulum posuere, justo odio bibendum urna, rutrum bibendum dolor sem nec tellus. 

\begin{lemma} [Quisque blandit tempus nunc]
Sed interdum nisl pretium non. Mauris sodales consequat risus vel consectetur. Aliquam erat volutpat. Nunc sed sapien ligula. Proin faucibus sapien luctus nisl feugiat convallis faucibus elit cursus. Nunc vestibulum nunc ac massa pretium pharetra. Nulla facilisis turpis id augue venenatis blandit. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus.
\end{lemma}

Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.

\section{Morbi eros magna}

Morbi eros magna, vestibulum non posuere non, porta eu quam. Maecenas vitae orci risus, eget imperdiet mauris. Donec massa mauris, pellentesque vel lobortis eu, molestie ac turpis. Sed condimentum convallis dolor, a dignissim est ultrices eu. Donec consectetur volutpat eros, et ornare dui ultricies id. Vivamus eu augue eget dolor euismod ultrices et sit amet nisi. Vivamus malesuada leo ac leo ullamcorper tempor. Donec justo mi, tempor vitae aliquet non, faucibus eu lacus. Donec dictum gravida neque, non porta turpis imperdiet eget. Curabitur quis euismod ligula. 


%%
%% Bibliography
%%

%% Please use bibtex, 

\bibliography{src/references}

\appendix

\section{Styles of lists, enumerations, and descriptions}\label{sec:itemStyles}

List of different predefined enumeration styles:

\begin{itemize}
\item \verb|\begin{itemize}...\end{itemize}|
\item \dots
\item \dots
%\item \dots
\end{itemize}

\begin{enumerate}
\item \verb|\begin{enumerate}...\end{enumerate}|
\item \dots
\item \dots
%\item \dots
\end{enumerate}

\begin{alphaenumerate}
\item \verb|\begin{alphaenumerate}...\end{alphaenumerate}|
\item \dots
\item \dots
%\item \dots
\end{alphaenumerate}

\begin{romanenumerate}
\item \verb|\begin{romanenumerate}...\end{romanenumerate}|
\item \dots
\item \dots
%\item \dots
\end{romanenumerate}

\begin{bracketenumerate}
\item \verb|\begin{bracketenumerate}...\end{bracketenumerate}|
\item \dots
\item \dots
%\item \dots
\end{bracketenumerate}

\begin{description}
\item[Description 1] \verb|\begin{description} \item[Description 1]  ...\end{description}|
\item[Description 2] Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\item[Description 3]  \dots
%\item \dots
\end{description}

\cref{testenv-proposition} and \autoref{testenv-proposition} ...

\section{Theorem-like environments}\label{sec:theorem-environments}

List of different predefined enumeration styles:

\begin{theorem}\label{testenv-theorem}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{theorem}

\begin{lemma}\label{testenv-lemma}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{lemma}

\begin{corollary}\label{testenv-corollary}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{corollary}

\begin{proposition}\label{testenv-proposition}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{proposition}

\begin{conjecture}\label{testenv-conjecture}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{conjecture}

\begin{observation}\label{testenv-observation}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{observation}

\begin{exercise}\label{testenv-exercise}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{exercise}

\begin{definition}\label{testenv-definition}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{definition}

\begin{example}\label{testenv-example}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{example}

\begin{note}\label{testenv-note}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{note}

\begin{note*}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{note*}

\begin{remark}\label{testenv-remark}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{remark}

\begin{remark*}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{remark*}

\begin{claim}\label{testenv-claim}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{claim}

\begin{claim*}\label{testenv-claim2}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{claim*}

\begin{proof}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{proof}

\begin{claimproof}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{claimproof}

\end{document}
